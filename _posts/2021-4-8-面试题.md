---
layout:     post
title:      嵌入式软件面试题
date:       2021-4-8
author:     HB
header-img:
catalog: true
tags:
    - embedded
---
# 1、I2C接口与SPI和UART接口的区别
I2C线更少，我觉得比UART、SPI更为强大，但是技术上也更加麻烦些，因为I2C需要有双向IO的支
持，而且使用上拉电阻，我觉得抗干扰能力较弱，一般用于同一板卡上芯片之间的通信，较少用于远距离通信。SPI
实现要简单一些，UART需要固定的波特率，就是说两位数据的间隔要相等，而SPI则无所谓，因为它是有时钟的协
议。
# 2、嵌入式软件工程师面试题目01
https://www.cnblogs.com/ksht-wdyx/p/13523207.html

# 3、关键字volatile
　　一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。

　　volatile变量的几个例子：
　　　　1). 并行设备的硬件寄存器（如：状态寄存器）
　　　　2). 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)
　　　　3). 多线程应用中被几个任务共享的变量

　　一个参数既可以是const还可以是volatile，一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它





# 4.对变量或者对寄存器进行位操作：
　　写两段代码：第一段代码进行置位操作：（寄存器）的bit3，第二段代码进行清位操作：（寄存器）的bit3　
```
#define BIT3 (0x1<<3)
static int a;
void set_bit3(void)
{
    a |= BIT3;
}
void clear_bit3(void)
{
    a &= ~BIT3;
}
```


# 5、中断

# 6、malloc(0)
char   *ptr;
if ((ptr   =   (char   *)malloc(0))   ==   NULL)  
puts( "Got   a   null   pointer ");
else
puts( "Got   a   valid   pointer ");
上面程序在VC6.0下输出结果是：Got   a   valid   pointer
请问指针为NULL时指向哪里，分配的空间为0时又指向哪里？

当使用malloc后，只有在没有足够内存的情况下会返回NULL，或是出现异常报告。

malloc(0)，系统就已经帮你准备好了堆中的使用起始地址（不会为NULL)。但是你不能对该地址进行写操作（不是不允许），如果写了话，当调用free(ptr)就会产生异常报告（地址受损）。

 

NULL   一般预定义为   (void   *)0,指向0地址。malloc是在程序堆栈上分配空间，不会是0地址
malloc(0)是指分配内存大小为零
NULL是不指向任何实体
malloc(0)也是一种存在不是NULL

# 7.关键字_interrupt
　　中断是嵌入式系统中重要的组成部分，ISP（中断服务子程序）　　注意点：

　　a：ISR 不能返回一个值

　　b：ISR 不能传递参数

　　c：在许多的处理器/编译器中，浮点一般都是不可重入的，ISR应该是短而有效率的，在ISR中做浮点运算是不明智的。

　　d：与第三点一脉相承，printf()经常有重入和性能上的问题
  
# 8.引用与指针有什么区别　　
　　1) 引用必须被初始化，指针不必。

　　2) 引用初始化以后不能被改变，指针可以改变所指的对象。

　　3) 不存在指向空值的引用，但是存在指向空值的指针。
  
# 9.Internet采用哪种网络协议？该协议的主要层次结构
　　TCP/IP：应用层/传输层/网络层/数据链路层/物理层
  
# 10.Internet物理地址和IP地址转换采用什么协议
　　ARP协议（Address Resolution Protocol）:地址解析协议所谓“地址解析”就是主机在发送帧前将目标IP地址转换成目标MAC地址的过程。ARP协议的基本功能就是通过目标设备的IP地址，查询目标设备的MAC地址，以保证通信的顺利进行。

# 11.IP地址的编码分为哪两部分
　　网络号和主机号
# 12.局部变量能否和全局变量重名？ 　　
  答：能，局部会屏蔽全局。要用全局变量，需要使用 ":: " （域解析符）

　　  局部变量可以与全局变量同名，在函数内引用这个变量时，会用到同名的局部变量，而不会用到全局变量。对于有些编译器而言，在同一个函数内可以定义多个同名的局部变量，比如在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就在那个循环体内。
	
# 13.C语言在内存中一共分为如下几个区域，分别是

1. 内存栈区： 存放局部变量名；
2. 内存堆区： 存放new或者malloc出来的对象；
3. 常数区： 存放局部变量或者全局变量的值；
4. 静态区： 用于存放全局变量或者静态变量；
5. 代码区：二进制代码。
知道如上一些内存分配机制，有助于我们理解指针的概念。

C/C++不提供垃圾回收机制，因此需要对堆中的数据进行及时销毁，防止内存泄漏，使用free和delete销毁new和malloc申请的堆内存，而栈内存是动态释放。

全局变量、静态局部变量保存在全局数据区，初始化的和未初始化的分别保存在一起；

普通局部变量保存在堆栈中；

全局变量和局部变量在内存里的区别？ 

一、预备知识—程序的内存分配 

一个由c/C++编译的程序占用的内存分为以下几个部分 

1、栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 

2、堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。 


3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域（RW）， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域（ZI）。 - 程序结束后有系统释放 

4、文字常量区 —常量字符串就是放在这里的。 程序结束后由系统释放 （RO）

5、程序代码区—存放函数体的二进制代码。 （RO）
# 14.用宏定义写出swap（x，y）
　　#define swap(x, y) (x=x+y;y=x-y;x=x-y;) 
  
# 15.c 和c++ 中的struct有什么不同

c和c++ 中struct的主要区别是c中的struct不可以含有成员函数，而c++ 中的struct可以
c++ 中struct和class的主要区别在于默认的存取权限不同，struct默认为public ，而class默认为private
# 16.已知一个数组table，用一个宏定义，求出数据的元素个数
　#define KST (sizeof(table)/sizeof(table[0]))
# 17.进程之间通信的途径有哪些
　　1.无名管道

　　2.高级管道

　　3.有名管道

　　4.消息队列

　　5.信息量

　　6.信号

　　7.共享内存

　　8.套接字
# 18.静态语言和动态语言的区别：

区别一：

静态语言是在编译时变量的数据类型即可确定的语言，多数静态类型语言要求在使用变量之前必须声明数据类型；比如C/C++ 是静态类型语言的典型代表，其他的静态类型语言还有 C#、JAVA 等。

动态语言是在运行时确定数据类型的语言。变量使用之前不需要类型声明，通常变量的类型是被赋值的那个值的类型；像是Python 和 Ruby 就是一种典型的动态类型语言，其他的各种脚本语言如 JavaScript 也属于动态类型语言。

区别二：

静态类型语言编译时会进行类型匹配检查，所以不能给变量赋予不同类型的值。为了解决这一问题，静态类型的面向对象语言通常通过向上转型的技术来取得多态的效果。

动态类型语言的变量类型在运行期是可变的，这意味着对象的多态性是与生俱来的。一个对象能否执行某个操作，只取决于有没有对应的方法，而不取决于它是否是某种类型的对象。

区别三：

静态语言的优势：

由于类型的强制声明，使得IDE有很强的代码感知能力，故在实现复杂的业务逻辑、开发大型商业系统、以及那些生命周期很长的应用中，依托IDE对系统的开发很有保障；

由于静态语言相对比较封闭，使得第三方开发包对代码的侵害性可以降到最低；

动态语言的优势：

编写的代码数量更少，看起来更加简洁，可以把精力更多地放在业务逻辑上。虽然不区分类型在某些情况下会让程序变得难以理解，但整体而言，代码量越少，越专注于逻辑表达，对阅读程序越有帮助。



# 中断的本质是什么？

教材上会说中断是外部设备向处理器发起的请求事件，但这还不够本质。中断的本质是处理器对外开放的实时受控接口。一个没有中断的计算机体系是决定论的：得知某个时刻CPU和内存的全部数据状态，就可以推衍出未来的全部过程。这样的计算机无法交互，只是个加速器。添加中断后，计算机指定了会兼容哪些外部命令，并设定服务程序，这种服务可能打断当前任务。这使得CPU“正在执行的程序”与“随时可能发生的服务”，二者形成了异步关系，外界输入的引入使得计算机程序不再是决定论。由人实时控制的中断输入，是无法预测的。再将中断响应规则化，推广开，非计算机科学人群就能控制计算机，发挥创造力。电竞鼠标微操，数码板绘，音频输入合成，影像后期数值调整，键盘点评天下大势，这些都不是定势流程，是需要人实时创造参与其中的事件，就由中断作为载体，与计算机结合了起来。中断就是处理器的标准输入接口。至于硬件细节并不那么重要，取决于指令规范。可以直接拉外部引脚到CPU Retire单元；也可以内置一个中断控制器统筹接收外部信号，再做转发。x86上二者都有，后一项是由南桥发至IO APIC再发至核心APIC再发给Retire单元，而CPU也有一定的自由度，会在适当的时机响应。
# 1.CPU如何准确的定位到自己要想访问的某个外设呢？
# 2.CPU如果找到了要想访问的外设,CPU如何通过SCL,SDA和外设进行数据传输呢？
# 3.既然需要两根线,SDA和SCL,那么他们是如何搭配使用呢？
答案：答案在I2C总线协议中
      问：协议在哪里？
      答：协议就在I2C总线外设的芯片手册中
          切记：手册重点看时序
      一句话：协议就是时序,时序就是协议
      此时此刻大谈特谈I2C总线协议

5.5.首先谈谈I2C总线协议中相关的概念
slave:从设备,俗称外设
master:主设备,俗称CPU
MSB:高位
LSB:低位
timing：时序

START信号：又称起始信号,如果CPU要想访问总线上某个外设,CPU首先向总线
           发送一个START信号,并且此信号只能由CPU发起
           信号特征：SCL为高电平,SDA由高电平向低电平跳变会产生一个START信号
           类似：同学们,上课啦
STOP信号：又称结束信号,如果CPU结束对某个外设的访问,CPU只需向外设发送
          STOP信号即可,并且此信号只能由CPU发起
          信号特征：SCL为高电平,SDA由低电平向高电平跳变产生STOP信号
          类似：同学们,下课啦
读写位R/W：用于表示CPU是向外设写入数据还是从外设读取数据
			  有效位数为一位,如果CPU读:R/W=1;如果CPU写:R/W=0
设备地址：用于表示外设在同一个I2C总线上的唯一性
          也就是同一个I2C总线上的不同外设都有唯一的
          一个设备地址,类似：外设的身份证号
          也就是CPU要想访问某个外设,CPU只需向总线发送这个外设的
          设备地址即可,将来就能找到这个外设,类似：老师喊某个同学的名字			 
		    设备地址的有效位数有7位或者10位,常用为7位
		    问：设备地址如何确定呢？
		    答：设备地址由原理图和外设芯片手册共同来决定
		    此时此刻务必举例子阐述确定的过程：
		    1.以LM77温度传感器为例
		      打开其芯片手册lm77.pdf,P8,得到：
		      LM77设备地址=10010A1A0(两个引脚)
		      这里假设硬件工程师A1A0都接地,最终：
		      LM77设备地址=1001000(二进制)
		      软件表示形式16进制：设备地址=01001000=0x48
		    2.以MMA8653三轴加速度传感器为例
		      打开MMA8653芯片手册mma8653fcr1.pdf,P17
		      MMA8653的设备地址=0011101
		      软件表示形式16进制：设备地址=00011101=0x1D
		    3.以ADP8860背光灯控制芯片为例
		      打开ADP8860芯片手册,ADP8860.pdf,P26
		      ADP8860设备地址=0101010(注意不要带x=R/W噢)
		      软件表示形式16进制：设备地址=	00101010= 0x2A		      
		    		    
读设备地址：读设备地址=设备地址<<1|R/W=1
写设备地址：写设备地址=设备地址<<1|R/W=0
            问：为啥存在读和写设备地址？
            答：根据I2C总线传输的原则：一次以字节
            由于设备地址7位,而读写位为1位,抱团取暖,凑够8位
            正好符合原则,由于读写=1/0,所以诞生了读或者写设备地址

ACK信号：又称应答信号,用于表示双方的数据传输过程是否出现问题
         有效电平为低电平,有效位数1位

切记切记切记：
1.I2C数据传输过程中,如果出现读写方向改变,必须重新发送START和设备地址和读写位
2.只要是I2C接口的外设,芯片内部必然有寄存器,这类寄存器简称片内寄存器
  并且这些寄存器都有唯一的物理地址,这些物理地址的编址都是从0x00开始
  所以与其说是CPU访问外设,不如说是CPU访问片内寄存器中的数据
3.问：既然片内寄存器有物理地址,为啥不能直接以地址指针的形式访问呢？
  还非要苦哈哈的发时序访问呢？
  答：因为片内寄存器跟CPU之间没有地址线,所以CPU不能以地址直接寻址
      所以CPU只能按照时序访问！
          
结论：通过概念可以解答三个问题的其中一个问题：
CPU如何找到某个外设呢？
答：CPU只需向总线发送这个外设的设备地址即可




# 4.问：CPU如何和外设进行数据交互呢？
    答：此时此刻务必举例子并且边说边画框框圈圈图
        阐述传输的过程[不同芯片传输过程不一致的]
1.以CPU读取LM77温度传感器内部2字节数据为例,传输过程如下
1.1.先打开LM77芯片手册,P12,图"Typical 2-Byte Read From Registers" 根据时序图得到,   
1.2.CPU首先向总线发送START信号
1.3.CPU然后向总线发送LM77的读设备地址10010001(100100<<1|1)
    找到LM77并且告诉LM77要从其读取数据
1.4.如果LM77存在于总线上,LM77在第九个时钟周期给CPU一个有效的低电平的
    ACK信号
1.5.然后LM77将2字节的高字节数据发送给CPU
1.6.CPU读取完毕同样在第九个时钟周期给LM77一个ACK信号
1.7.然后LM77将2字节的低字节数据发送给CPU
1.8.CPU在第九个时钟周期发送一个无效的高电平ACK
1.9.CPU最后发送STOP结束读取
1.10.画框框圈圈图,参见lm77.png

# 5.以CPU读取MMA8653内部集成的某个片内寄存器中的数据1字节为例 要求：具体来说MMA8653都有ID,存在寄存器地址为0x0D这个寄存器中,并且ID值为0x5A,现在将这个0x5A读取上来
2.1.打开MMA8653芯片手册,P17(Single-Byte Read timing (I2C))图,得到：
2.2.CPU先发START信号
2.3.CPU发送写设备地址:0x1D<<1|0
2.4.外设给CPU有效ACK
2.5.CPU发送MMA8653片内寄存器地址0x0D
    因为其内部的寄存器特别多,CPU得告诉他要访问哪个寄存器
2.6.外设再给CPU有效ACK
2.7.由于CPU要从外设读取数据,读写方向发生改变
    必须重新发送START信号
2.8.必须重新发送读设备地址：0x1D<<1|1
    告诉对方现在要读取数据
2.9.外设给CPU有效ACK
2.10.外设然后将0x0D寄存器中的数据0x5A发送给CPU
2.11.CPU在第九个时钟周期发送一个无效的高电平ACK
2.12.CPU最后发送STOP结束读取
2.13.画框框圈圈图,参见mma8653.png  

# 6.SCL和SDA如何搭配使用呢？[放大招:如果考官不愿意听前面,直接大招走起]
答：就四个字：低放高取
阐述说明四个字：
CPU向外设发送数据：
CPU在SCL为低电平时将数据放到数据线SDA上(就是拉高或者拉低SDA)
然后CPU将SCL拉高,然后外设就在同周期的SCL为高电平时从SDA数据线上读取数据













# 7.CPU发送数据的流程：
	         1.配置I2C控制器为发送模式
	         2.将设备地址和读写位0写入到I2CDS寄存器
	         3.向I2CSTAT寄存器写入0x0F,配置为发送模式并且发送一个START
	         4.I2C控制器自动将I2CDS中的写设备地址发送到SDA上
	         5.如果对方给CPU一个ACK,会产生一个中断信号
	           只需判断是否有中断到来即可
	         6.如果中断到来,并且想发送一个新的数据,只需将新的数据
	           放到I2CDS寄存器中
	         7.然后清除中断到来的标志位让I2C控制器继续发送数据
	         8.硬件上自动将I2CDS中新的数据发送到SDA上
	         9.如果数据发送完毕,只需判断中断是否到来
	           中断到来也表示ACK接收到
	         10.如果继续发送数据,只需重复6~9这些步骤
	            实现一个多次发送数据的流程        
	         11.如果不想发送数据,只需向I2CSTAT寄存器写0xD0
	            启动STOP信号
	         12.最后清除中断到来的标志位
	         13.面试时，如果考官问,画流程图          
# 	     8.CPU接收数据的流程：
	         1.配置I2C控制器为主接收模式
	         2.将设备地址和读写位1写入到I2CDS寄存器 
	         3.向I2CSTAT寄存器写入0xB0,配置为接收模式并且发送一个START
	         4.I2C控制器自动将I2CDS中的读设备地址发送到SDA上
	         5.如果对方给CPU一个ACK,会产生一个中断信号
	           只需判断是否有中断到来即可
	           还有CPU可以通过判断中断是否到来来决定是否从I2CDS
	           中继续读取新数据
	         6.如果中断到来了,说明数据准备就绪,CPU继续从I2CDS中
	           读取数据
	         7.然后清除中断到来的标志位让I2C控制器继续接收数据
	         8.SDA数据线上的数据自动得保存到I2CDS中
	         9.如果中断到来了,说明数据准备就绪,CPU继续从I2CDS中          
	           读取数据
	         10.如果要重复读取数据,重复5~9步骤
	         11.如果不想接收数据,只需向I2CSTAT寄存器写0x90          
	                                             启动STOP信号
	         12.最后清除中断到来的标志位                                    
	         13.面试时，如果考官问,画流程图     















