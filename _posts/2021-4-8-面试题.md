---
layout:     post
title:      嵌入式软件面试题
date:       2021-4-8
author:     HB
header-img:
catalog: true
tags:
    - embedded
---
# 1、I2C接口与SPI和UART接口的区别
I2C线更少，我觉得比UART、SPI更为强大，但是技术上也更加麻烦些，因为I2C需要有双向IO的支
持，而且使用上拉电阻，我觉得抗干扰能力较弱，一般用于同一板卡上芯片之间的通信，较少用于远距离通信。SPI
实现要简单一些，UART需要固定的波特率，就是说两位数据的间隔要相等，而SPI则无所谓，因为它是有时钟的协
议。
# 2、嵌入式软件工程师面试题目01
https://www.cnblogs.com/ksht-wdyx/p/13523207.html

# 3、关键字volatile
　　一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。

　　volatile变量的几个例子：
　　　　1). 并行设备的硬件寄存器（如：状态寄存器）
　　　　2). 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)
　　　　3). 多线程应用中被几个任务共享的变量

　　一个参数既可以是const还可以是volatile，一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它





# 4.对变量或者对寄存器进行位操作：
　　写两段代码：第一段代码进行置位操作：（寄存器）的bit3，第二段代码进行清位操作：（寄存器）的bit3　
```
#define BIT3 (0x1<<3)
static int a;
void set_bit3(void)
{
    a |= BIT3;
}
void clear_bit3(void)
{
    a &= ~BIT3;
}
```


# 5、中断

# 6、malloc(0)
char   *ptr;
if ((ptr   =   (char   *)malloc(0))   ==   NULL)  
puts( "Got   a   null   pointer ");
else
puts( "Got   a   valid   pointer ");
上面程序在VC6.0下输出结果是：Got   a   valid   pointer
请问指针为NULL时指向哪里，分配的空间为0时又指向哪里？

当使用malloc后，只有在没有足够内存的情况下会返回NULL，或是出现异常报告。

malloc(0)，系统就已经帮你准备好了堆中的使用起始地址（不会为NULL)。但是你不能对该地址进行写操作（不是不允许），如果写了话，当调用free(ptr)就会产生异常报告（地址受损）。

 

NULL   一般预定义为   (void   *)0,指向0地址。malloc是在程序堆栈上分配空间，不会是0地址
malloc(0)是指分配内存大小为零
NULL是不指向任何实体
malloc(0)也是一种存在不是NULL

# 7.关键字_interrupt
　　中断是嵌入式系统中重要的组成部分，ISP（中断服务子程序）　　注意点：

　　a：ISR 不能返回一个值

　　b：ISR 不能传递参数

　　c：在许多的处理器/编译器中，浮点一般都是不可重入的，ISR应该是短而有效率的，在ISR中做浮点运算是不明智的。

　　d：与第三点一脉相承，printf()经常有重入和性能上的问题
  
# 8.引用与指针有什么区别　　
　　1) 引用必须被初始化，指针不必。

　　2) 引用初始化以后不能被改变，指针可以改变所指的对象。

　　3) 不存在指向空值的引用，但是存在指向空值的指针。
  
# 9.Internet采用哪种网络协议？该协议的主要层次结构
　　TCP/IP：应用层/传输层/网络层/数据链路层/物理层
  
# 10.Internet物理地址和IP地址转换采用什么协议
　　ARP协议（Address Resolution Protocol）:地址解析协议所谓“地址解析”就是主机在发送帧前将目标IP地址转换成目标MAC地址的过程。ARP协议的基本功能就是通过目标设备的IP地址，查询目标设备的MAC地址，以保证通信的顺利进行。

# 11.IP地址的编码分为哪两部分
　　网络号和主机号
# 12.局部变量能否和全局变量重名？ 　　
  答：能，局部会屏蔽全局。要用全局变量，需要使用 ":: " （域解析符）

　　  局部变量可以与全局变量同名，在函数内引用这个变量时，会用到同名的局部变量，而不会用到全局变量。对于有些编译器而言，在同一个函数内可以定义多个同名的局部变量，比如在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就在那个循环体内。
	
# 13.C语言在内存中一共分为如下几个区域，分别是

1. 内存栈区： 存放局部变量名；
2. 内存堆区： 存放new或者malloc出来的对象；
3. 常数区： 存放局部变量或者全局变量的值；
4. 静态区： 用于存放全局变量或者静态变量；
5. 代码区：二进制代码。
知道如上一些内存分配机制，有助于我们理解指针的概念。

C/C++不提供垃圾回收机制，因此需要对堆中的数据进行及时销毁，防止内存泄漏，使用free和delete销毁new和malloc申请的堆内存，而栈内存是动态释放。

全局变量、静态局部变量保存在全局数据区，初始化的和未初始化的分别保存在一起；

普通局部变量保存在堆栈中；

全局变量和局部变量在内存里的区别？ 

一、预备知识—程序的内存分配 

一个由c/C++编译的程序占用的内存分为以下几个部分 

1、栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 

2、堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。 


3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域（RW）， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域（ZI）。 - 程序结束后有系统释放 

4、文字常量区 —常量字符串就是放在这里的。 程序结束后由系统释放 （RO）

5、程序代码区—存放函数体的二进制代码。 （RO）
# 14.用宏定义写出swap（x，y）
　　#define swap(x, y) (x=x+y;y=x-y;x=x-y;) 
  
# 15.c 和c++ 中的struct有什么不同

c和c++ 中struct的主要区别是c中的struct不可以含有成员函数，而c++ 中的struct可以
c++ 中struct和class的主要区别在于默认的存取权限不同，struct默认为public ，而class默认为private
# 16.已知一个数组table，用一个宏定义，求出数据的元素个数
　#define KST (sizeof(table)/sizeof(table[0]))
# 17.进程之间通信的途径有哪些
　　1.无名管道

　　2.高级管道

　　3.有名管道

　　4.消息队列

　　5.信息量

　　6.信号

　　7.共享内存

　　8.套接字
# 18.静态语言和动态语言的区别：

区别一：

静态语言是在编译时变量的数据类型即可确定的语言，多数静态类型语言要求在使用变量之前必须声明数据类型；比如C/C++ 是静态类型语言的典型代表，其他的静态类型语言还有 C#、JAVA 等。

动态语言是在运行时确定数据类型的语言。变量使用之前不需要类型声明，通常变量的类型是被赋值的那个值的类型；像是Python 和 Ruby 就是一种典型的动态类型语言，其他的各种脚本语言如 JavaScript 也属于动态类型语言。

区别二：

静态类型语言编译时会进行类型匹配检查，所以不能给变量赋予不同类型的值。为了解决这一问题，静态类型的面向对象语言通常通过向上转型的技术来取得多态的效果。

动态类型语言的变量类型在运行期是可变的，这意味着对象的多态性是与生俱来的。一个对象能否执行某个操作，只取决于有没有对应的方法，而不取决于它是否是某种类型的对象。

区别三：

静态语言的优势：

由于类型的强制声明，使得IDE有很强的代码感知能力，故在实现复杂的业务逻辑、开发大型商业系统、以及那些生命周期很长的应用中，依托IDE对系统的开发很有保障；

由于静态语言相对比较封闭，使得第三方开发包对代码的侵害性可以降到最低；

动态语言的优势：

编写的代码数量更少，看起来更加简洁，可以把精力更多地放在业务逻辑上。虽然不区分类型在某些情况下会让程序变得难以理解，但整体而言，代码量越少，越专注于逻辑表达，对阅读程序越有帮助。



# 中断的本质是什么？

教材上会说中断是外部设备向处理器发起的请求事件，但这还不够本质。中断的本质是处理器对外开放的实时受控接口。一个没有中断的计算机体系是决定论的：得知某个时刻CPU和内存的全部数据状态，就可以推衍出未来的全部过程。这样的计算机无法交互，只是个加速器。添加中断后，计算机指定了会兼容哪些外部命令，并设定服务程序，这种服务可能打断当前任务。这使得CPU“正在执行的程序”与“随时可能发生的服务”，二者形成了异步关系，外界输入的引入使得计算机程序不再是决定论。由人实时控制的中断输入，是无法预测的。再将中断响应规则化，推广开，非计算机科学人群就能控制计算机，发挥创造力。电竞鼠标微操，数码板绘，音频输入合成，影像后期数值调整，键盘点评天下大势，这些都不是定势流程，是需要人实时创造参与其中的事件，就由中断作为载体，与计算机结合了起来。中断就是处理器的标准输入接口。至于硬件细节并不那么重要，取决于指令规范。可以直接拉外部引脚到CPU Retire单元；也可以内置一个中断控制器统筹接收外部信号，再做转发。x86上二者都有，后一项是由南桥发至IO APIC再发至核心APIC再发给Retire单元，而CPU也有一定的自由度，会在适当的时机响应。

