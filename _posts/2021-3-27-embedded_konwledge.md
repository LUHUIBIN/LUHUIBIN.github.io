---
layout:     post
title:      embedded knowledge
date:       2021-3-27
author:     HB
header-img:
catalog: true
tags:
    - embedded
---

# 按键去抖
硬件消抖

在键数较少时可用硬件方法消除键抖动。下图所示的RS触发器为常用的硬件去抖。

![](http://news.eeworld.com.cn/uploadfile/mcu/uploadfile/201208/20120806045711275.jpg)

图中两个“与非”门构成一个RS触发器。当按键未按下时，输出为1;当键按下时，输出为0。此时即使用按键的机械性能，使按键因弹性抖动而产生瞬时断开（抖动跳开B），中要按键不返回原始状态A，双稳态电路的状态不改变，输出保持为0，不会产生抖动的波形。也就是说，即使B点的电压波形是抖动的，但经双稳态电路之后，其输出为正规的矩形波。这一点通过分析RS触发器的工作过程很容易得到验证。

另一种硬件消抖的方法利用电容的放电延时，采用并联电容法，也可以实现硬件消抖，如图3所示：

![](http://news.eeworld.com.cn/uploadfile/mcu/uploadfile/201208/20120806045712217.jpg)

软件消抖

如果按键较多，常用软件方法去抖，即检测出键闭合后执行一个延时程序，5ms～10ms的延时，让前沿抖动消失后再一次检测键的状态，如果仍保持闭合状态电平，则确认为真正有键按下。当检测到按键释放后，也要给5ms～10ms的延时，待后沿抖动消失后才能转入该键的处理程序。还可以利用定时器中断来消抖。




------------
# http协议
## HTTP请求
下图是在网上找的一张图，觉得能很好的表达HTTP请求的所发送的数据格式。
HTTP请求正文


![](https://pic2.zhimg.com/80/v2-12836e928e97f0d1acf375b34981a071_720w.jpg)
由上图可以看到，http请求由请求行，消息报头，请求正文三部分构成。

### HTTP请求状态行
请求行由请求Method, URL 字段和HTTP Version三部分构成, 总的来说请求行就是定义了本次请求的请求方式, 请求的地址, 以及所遵循的HTTP协议版本例如：

GET /example.html HTTP/1.1 (CRLF)
HTTP协议的方法有： GET： 请求获取Request-URI所标识的资源 POST： 在Request-URI所标识的资源后增加新的数据 HEAD： 请求获取由Request-URI所标识的资源的响应消息报头 PUT： 请求服务器存储或修改一个资源，并用Request-URI作为其标识 DELETE： 请求服务器删除Request-URI所标识的资源 TRACE： 请求服务器回送收到的请求信息，主要用于测试或诊断 CONNECT： 保留将来使用 OPTIONS： 请求查询服务器的性能，或者查询与资源相关的选项和需求

### HTTP请求头

HTTP请求报文
只有在发送POST请求时才会有请求正文，GET方法并没有请求正文。
![](https://pic4.zhimg.com/80/v2-839818777263adb12e93aafda6595633_720w.jpg)


## HTTP响应报文

![](https://pic1.zhimg.com/80/v2-d85efb19aec970b506b8cc7d2a2821dc_720w.jpg)

# 状态机
状态机由状态寄存器和组合逻辑电路构成，能够根据控制信号按照预先设定的状态进行状态转移，是协调相关信号动作、完成特定操作的控制中心。有限状态机简写为FSM（Finite State Machine），主要分为2大类：
***第一类，若输出只和状态有关而与输入无关，则称为Moore状态机
第二类，输出不仅和状态有关而且和输入有关系，则称为Mealy状态机***

## 基本信息
状态机由状态寄存器和组合逻辑电路构成，能够根据控制信号按照预先设定的状态进行状态转移，是协调相关信号动作,完成特定操作的控制中心。状态机分为摩尔（Moore）型状态机和米莉（Mealy）型状态机。 [1] 
状态机就是状态转移图。举个最简单的例子，人有三个状态：健康，感冒，康复中。触发的条件有淋雨（t1），吃药（t2），打针（t3），休息（t4）。所以状态机就是健康-（t4）->健康；健康-（t1）->感冒；感冒-（t3）->健康；感冒-（t2）->康复中；康复中-（t4）->健康，等等。就是这样状态在不同的条件下跳转到自己或不同状态的图。

# GDB调试
[GDB调试指南守望的个人博客](https://www.yanbinghu.com/2019/04/20/41283.html "GDB调试指南")



# 堆和栈的区别是什么

1.管理方式:
对于栈来讲,是由编译自动管理,无需我们手工控制;对于堆来说,释放工作由程序员控制,容易产生内存泄漏.
2.申请大小:
栈:在Windows下,栈是向低地址扩展的数据结构,是一块连续的内存区域.就是栈顶的地址和栈的最大容量是系统预先规定好的,在windows下,栈的大小为2m(也有说1m,总之是一个编译时就确定的常数),如果申请的空间超过栈的剩余空间时,将提示overflow.因此能从栈获得的空间较小.
堆:堆是向高地址扩展的数据结构,是不连续的内存区域.这是由于系统是用链表来存储的空闲内存地址,自然是不连续的,而链表的遍历方向是由低地址向高地址.堆得大小受限于计算机系统中有效的虚拟内存.由此可见,堆获得的空间比较灵活,也比较大.
3.碎片问题:
对于堆来讲,频繁的new/delete势必会造成内存空间的不连续,从而造成大量的碎片,使程序效率降低.对于栈来讲,则不会存在这个问题,因为栈是先进后出的队列,他们是如此的--对应,以至于永远都不可能有一个内存块从栈中间弹出.
4.分配方式:
堆都是动态分配的,没有静态分配的堆.栈有两种分配方式:静态分配和动态分配.静态分配是编译器完成的,比如局部变量的分配.动态分配由alloc函数进行分配,但是栈的动态分配和堆是不同的,他的动态分配是由编译器进行释放,无需我们手工实现.
5.分配效率:
栈是机器系统提供的数据结构,计算机会在底层对栈提供支持:分配专门的寄存器存放栈的地址,压栈出栈都有专门的指令执行,这就决定了栈的效率比较高.堆则是c/c++函数提供的,他的机制很复杂.

# malloc()与 alloc()区别
C语言跟内存 分配方式
（ 1） 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。
（ 2） 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
（ 3 ） 从堆上分配，亦称动态内存分配。程序在运行的时候用 malloc 或 new 申请任意多少的内存，程序员自己负责在何时用 free 或 delete 释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多
C语言跟内存申请相关的函数主要有 alloca,calloc,malloc,free,realloc,sbrk等.
alloca是向栈申请内存,因此无需释放。
malloc 分配的内存是位于 堆中 的,并且没有 初始化内存的内容 ,因此基本上malloc之后,调用函数memset来初始化这部分的内存空间,需要用 Free 方式释放空间.
calloc则将初始化malloc这部分的内存,设置为0. 
realloc则对malloc申请的内存进行大小的调整.
free将malloc申请的内存最终需要通过该函数进行释放. 
sbrk则是增加数据段的大小;
