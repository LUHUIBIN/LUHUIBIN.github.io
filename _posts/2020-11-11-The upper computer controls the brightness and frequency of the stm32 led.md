---
layout:     post
title:      The upper computer controls the brightness and frequency of the stm32 led
date:       2020-11-11
author:     HB
header-img:
catalog: true
tags:
    - QT
---

- 题目要求：

1.上位机通过串口发送数据到stm32，使stm32的led0和led1的频率和亮度改变。

2.上位机可以读出当前led的亮度频率数值

3.当stm32按下按键，在上位机会收到信息关于哪一个按键被按下了。

该代码来自nyx。用到了pyqt5的qtdesiner和pyuic5，将画出来的ui文件转化为py文件。节省了时间和精力。


可运行代码在这里(链接https://pan.baidu.com/s/1yT51Kqm8fiq6jEL1tSCWAA
提取码：zjmu )
### 上位机
- Usart.py

```python
import sys
import serial
from PyQt5.QtCore import *
from PyQt5.QtGui import *
from PyQt5.QtWidgets import *
from PyQt5.QtSerialPort import QSerialPort, QSerialPortInfo
import LedBox

  #qt窗口显示
class mainui(QWidget):
    def __init__(self,parent=None):
        super(mainui, self).__init__(parent)
        self.initUI()
    def initUI(self):
        self.ui = LedBox.Ui_LedEvent()
        self.serial1 = QSerialPort()
        self.serial1.setPortName("COM3")
        self.serial1.setBaudRate(115200)
        self.serial1.readyRead.connect(self.serial_rcved)
        self.serial1.open(QIODevice.ReadWrite)
        #self.serial0 = serial.Serial('COM3', 115200, timeout=0.1)
        #print(self.serial0)
        #if self.serial0.isOpen():
            #print('串口已打开')
            ##self.serial0.close()
        #self.rcvthread = serialrecieved(self.serial0)

        #self.rcvthread.start()
        #self.rcvthread.recieved.connect(self.serial_rcved)
        self.ui.setupUi(self)
        self.setWindowTitle("控制LED灯")
        self.setWindowIcon(QIcon(':/images/timg.jfif'))
        #MainWindow.show()
        # 控件信号连接槽函数
        self.ui.ledBox.currentIndexChanged.connect(self.slot_led)
        self.ui.brightBox.currentIndexChanged.connect(self.slot_brightness)
        self.ui.frequencyBox.currentIndexChanged.connect(self.slot_frequency)
        self.ui.ok.clicked.connect(self.slot_ok)
        self.ui.receive.clicked.connect(self.slot_receive)

    # 定义需要的槽函数
    def serial_rcved(self):
        print("recieved")
        a = self.serial1.readAll()
        a = bytes(a)
        print(a)
        str = a.decode("utf-8","ignore")
        self.ui.textEdit.append(str)
    def slot_led(self):
        print('led selection changed', self.ui.ledBox.currentText())

    def slot_brightness(self):
        print('brightness selection changed', self.ui.brightBox.currentText())

    def slot_frequency(self):
        print('frequency selection changed', self.ui.frequencyBox.currentText())

    def slot_ok(self):
        led_choose = self.ui.ledBox.currentText()
        brightness_choose = self.ui.brightBox.currentText()
        frequency_choose = self.ui.frequencyBox.currentText()
        self.ui.textEdit.append('led:' + led_choose)
        self.ui.textEdit.append('brightness:' + brightness_choose)
        self.ui.textEdit.append('frequency:' + frequency_choose)
        data_send = "led set " + led_choose + " " + brightness_choose + " " + frequency_choose
        print(data_send)
        data_send = bytes(data_send, 'utf-8')
        data_send = data_send + b'\r\n'
        #self.serial0.open()
        self.serial1.write(data_send) # 串口写数据

    def slot_receive(self):
        print("ok")
if __name__ == '__main__':
  app = QApplication(sys.argv)
  newui = mainui()
  newui.show()
  sys.exit(app.exec_())
```
- LedBox.py

```python

# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'LedBox.ui'
#
# Created by: PyQt5 UI code generator 5.15.1
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets


class Ui_LedEvent(object):
    def setupUi(self, LedEvent):
        LedEvent.setObjectName("LedEvent")
        LedEvent.resize(420, 436)
        self.frequencyBox = QtWidgets.QComboBox(LedEvent)
        self.frequencyBox.setGeometry(QtCore.QRect(260, 80, 69, 22))
        self.frequencyBox.setModelColumn(0)
        self.frequencyBox.setObjectName("frequencyBox")
        self.frequencyBox.addItem("")
        self.frequencyBox.addItem("")
        self.frequencyBox.addItem("")
        self.frequencyBox.addItem("")
        self.frequencyBox.addItem("")
        self.frequencyBox.addItem("")
        self.frequencyBox.addItem("")
        self.frequencyBox.addItem("")
        self.brightBox = QtWidgets.QComboBox(LedEvent)
        self.brightBox.setGeometry(QtCore.QRect(260, 130, 69, 22))
        self.brightBox.setObjectName("brightBox")
        self.brightBox.addItem("")
        self.brightBox.addItem("")
        self.brightBox.addItem("")
        self.brightBox.addItem("")
        self.brightBox.addItem("")
        self.brightBox.addItem("")
        self.brightBox.addItem("")
        self.label = QtWidgets.QLabel(LedEvent)
        self.label.setGeometry(QtCore.QRect(210, 90, 54, 12))
        self.label.setObjectName("label")
        self.label_2 = QtWidgets.QLabel(LedEvent)
        self.label_2.setGeometry(QtCore.QRect(210, 130, 54, 12))
        self.label_2.setObjectName("label_2")
        self.ledBox = QtWidgets.QComboBox(LedEvent)
        self.ledBox.setGeometry(QtCore.QRect(70, 90, 69, 22))
        self.ledBox.setObjectName("ledBox")
        self.ledBox.addItem("")
        self.ledBox.addItem("")
        self.label_3 = QtWidgets.QLabel(LedEvent)
        self.label_3.setGeometry(QtCore.QRect(40, 90, 54, 20))
        self.label_3.setObjectName("label_3")
        self.ok = QtWidgets.QPushButton(LedEvent)
        self.ok.setGeometry(QtCore.QRect(80, 190, 75, 23))
        self.ok.setObjectName("ok")
        self.textclear = QtWidgets.QPushButton(LedEvent)
        self.textclear.setGeometry(QtCore.QRect(230, 190, 75, 23))
        self.textclear.setObjectName("textclear")
        self.textEdit = QtWidgets.QTextEdit(LedEvent)
        self.textEdit.setGeometry(QtCore.QRect(60, 240, 271, 141))
        self.textEdit.setObjectName("textEdit")

        self.retranslateUi(LedEvent)
        QtCore.QMetaObject.connectSlotsByName(LedEvent)

    def retranslateUi(self, LedEvent):
        _translate = QtCore.QCoreApplication.translate
        LedEvent.setWindowTitle(_translate("LedEvent", "Dialog"))
        self.frequencyBox.setItemText(0, _translate("LedEvent", "0.5"))
        self.frequencyBox.setItemText(1, _translate("LedEvent", "1"))
        self.frequencyBox.setItemText(2, _translate("LedEvent", "5"))
        self.frequencyBox.setItemText(3, _translate("LedEvent", "10"))
        self.frequencyBox.setItemText(4, _translate("LedEvent", "20"))
        self.frequencyBox.setItemText(5, _translate("LedEvent", "50"))
        self.frequencyBox.setItemText(6, _translate("LedEvent", "80"))
        self.frequencyBox.setItemText(7, _translate("LedEvent", "100"))
        self.brightBox.setItemText(0, _translate("LedEvent", "0"))
        self.brightBox.setItemText(1, _translate("LedEvent", "5"))
        self.brightBox.setItemText(2, _translate("LedEvent", "10"))
        self.brightBox.setItemText(3, _translate("LedEvent", "20"))
        self.brightBox.setItemText(4, _translate("LedEvent", "50"))
        self.brightBox.setItemText(5, _translate("LedEvent", "80"))
        self.brightBox.setItemText(6, _translate("LedEvent", "100"))
        self.label.setText(_translate("LedEvent", "频率"))
        self.label_2.setText(_translate("LedEvent", "亮度"))
        self.ledBox.setItemText(0, _translate("LedEvent", "ds0"))
        self.ledBox.setItemText(1, _translate("LedEvent", "ds1"))
        self.label_3.setText(_translate("LedEvent", "LED"))
        self.ok.setText(_translate("LedEvent", "确认"))
        self.textclear.setText(_translate("LedEvent", "清除"))

```

### 下位机

- main.

```python
#include "sys.h"
#include "delay.h"
#include "usart.h"
#include "led.h"
#include "key.h"
#include "timer.h"
#include "string.h"
#include "stdio.h"
#include "stdlib.h"
char* str[5] ;
int main(void)
{
	u8 dir=1;
	u8 key;
	u8 len;
	u8 t;
	int flag_led=0;
	int brightness;
	int frequency;

	int times;

  HAL_Init();                    	 	//初始化hal库  
  Stm32_Clock_Init(RCC_PLL_MUL9);   	//设置时钟，72M
	uart_init(115200);					//初始化串口
	LED_Init();							
	KEY_Init();							
	TIM3_Init(6,999);
	HAL_NVIC_EnableIRQ(TIM3_IRQn);
	TIM4_Init(6,9999);
	HAL_NVIC_EnableIRQ(TIM4_IRQn);
	LED0=0;
	LED1=0;
	while(1)
    {					
		if(USART_RX_STA&0x8000)
		{		
				int x=0,i=0;	   
				len=USART_RX_STA&0x3fff;//获取收到的数据的长度
				HAL_UART_Transmit(&UART1_Handler,(uint8_t*)USART_RX_BUF,len,1000);	//发送接收到的数据
				while(__HAL_UART_GET_FLAG(&UART1_Handler,UART_FLAG_TC)!=SET);		//等待数据发送结束
				//printf("\r\n\r\n");//插入回车换行

				if(strcmp(USART_RX_BUF,"led")>0)
				{
					 char* token = strtok(USART_RX_BUF, " ");//对接收到的数据进行字符串分割
					 t=0;
					 while( token != NULL )
					 {
						 //printf( "token:%s\n", token );
						 str[t]=token;
						 //printf("str:%s",str[t]);

						token = strtok(NULL, " ");//此处为什么是NULL?
						t++;
					 }

					//判断是哪一个led
					if (strcmp(str[2],"ds0")==0 )
					{
						flag_led = 1;
					}
					else if(strcmp(str[2],"ds1")==0 )
					{
							flag_led = 2;
					}
					brightness = atoi(str[3]);
					//printf("%d\r\n",a);
					if(brightness>=0&&brightness<=100)
					{
						brightness=brightness;
					}

					frequency=atoi(str[4]);
					if(frequency>=0)
						frequency = frequency;
				}
				//清空寄存器
				for(i=0;i<len;i++)
				{
					USART_RX_BUF[i]=NULL;

				}
				 USART_RX_STA=0;  
		}

				//根据传来的数据设置led的亮度和频率
        if(flag_led==1)            //DS0
        {    
					led0duty=brightness;
					led0timer = 1000/frequency;
					printf("led0 at %d %d",led0duty,frequency);
           flag_led =0;
        }
        else if(flag_led==2)        //DS1
        {
					led1duty=brightness;
					led1timer = 1000/frequency;
					printf("led1 at %d%d",led1duty,frequency);
          flag_led =0;
        }     
		//按键功能

		key=KEY_Scan(0);           
		switch(key)
		{		

			case KEY0_PRES:
				printf("key0 pressed");
				break;					
			case KEY1_PRES:
				printf("key1 pressed");
				break;
			default:
				break;
		}
		delay_ms(10);
	}		
}
```
- timer.

```python
#include "sys.h"
#include "delay.h"
#include "usart.h"
#include "led.h"
#include "key.h"
#include "timer.h"
//////////////////////////////////////////////////////////////////////////////////	 
//本程序只供学习使用，未经作者许可，不得用于其它任何用途
//ALIENTEK STM32F103开发板
//定时器中断驱动代码	   
//正点原子@ALIENTEK
//技术论坛:www.openedv.com
//创建日期:2019/9/17
//版本：V1.0
//版权所有，盗版必究。
//Copyright(C) 广州市星翼电子科技有限公司 2014-2024
//All rights reserved									  
////////////////////////////////////////////////////////////////////////////////// 	
TIM_HandleTypeDef 	TIM3_Handler;      	//定时器句柄
TIM_OC_InitTypeDef 	TIM3_CH2Handler;	//定时器3通道2句柄
TIM_HandleTypeDef 	TIM4_Handler;      	//定时器句柄
TIM_OC_InitTypeDef 	TIM4_CH2Handler;	//定时器3通道2句柄
uint8_t period = 100;
uint8_t led0timer3count=0;
uint8_t led1timer3count=0;
uint8_t led0onoff=1;
uint16_t led0timer=1000;
uint8_t led1onoff=1;
uint16_t led1timer=1000;
uint8_t led0duty = 50;
uint8_t led1duty =50;
uint16_t led0timer4count =0;
uint16_t led1timer4count=0;
//通用定时器3中断初始化
//arr：自动重装值。
//psc：时钟预分频数
//定时器溢出时间计算方法:Tout=((arr+1)*(psc+1))/Ft us.
//Ft=定时器工作频率,单位:Mhz
//这里使用的是定时器3!
void TIM3_Init(u16 arr,u16 psc)
{  
    TIM3_Handler.Instance=TIM3;                          //通用定时器3
    TIM3_Handler.Init.Prescaler=psc;                     //分频系数
    TIM3_Handler.Init.CounterMode=TIM_COUNTERMODE_UP;    //向上计数器
    TIM3_Handler.Init.Period=arr;                        //自动装载值
    TIM3_Handler.Init.ClockDivision=TIM_CLOCKDIVISION_DIV1;//时钟分频因子
    HAL_TIM_Base_Init(&TIM3_Handler);

    HAL_TIM_Base_Start_IT(&TIM3_Handler); //使能定时器3和定时器3更新中断：TIM_IT_UPDATE   
}
void TIM4_Init(u16 arr,u16 psc)
{  
    TIM4_Handler.Instance=TIM4;                          //通用定时器3
    TIM4_Handler.Init.Prescaler=psc;                     //分频系数
    TIM4_Handler.Init.CounterMode=TIM_COUNTERMODE_UP;    //向上计数器
    TIM4_Handler.Init.Period=arr;                        //自动装载值
    TIM4_Handler.Init.ClockDivision=TIM_CLOCKDIVISION_DIV1;//时钟分频因子
    HAL_TIM_Base_Init(&TIM4_Handler);

    HAL_TIM_Base_Start_IT(&TIM4_Handler); //使能定时器3和定时器3更新中断：TIM_IT_UPDATE   
}
//TIM3 PWM部分初始化
//arr：自动重装值。
//psc：时钟预分频数
//定时器溢出时间计算方法:Tout=((arr+1)*(psc+1))/Ft us.
//Ft=定时器工作频率,单位:Mhz
void TIM3_PWM_Init(u16 arr,u16 psc)
{  
    TIM3_Handler.Instance=TIM3;          	//定时器3
    TIM3_Handler.Init.Prescaler=psc;       //定时器分频
    TIM3_Handler.Init.CounterMode=TIM_COUNTERMODE_UP;//向上计数模式
    TIM3_Handler.Init.Period=arr;          //自动重装载值
    TIM3_Handler.Init.ClockDivision=TIM_CLOCKDIVISION_DIV1;
    HAL_TIM_PWM_Init(&TIM3_Handler);       //初始化PWM
    TIM3_CH2Handler.OCMode=TIM_OCMODE_PWM1; //模式选择PWM1
    TIM3_CH2Handler.Pulse=arr/2;            //设置比较值,此值用来确定占空比，默认比较值为自动重装载值的一半,即占空比为50%
    TIM3_CH2Handler.OCPolarity=TIM_OCPOLARITY_LOW; //输出比较极性为低
    HAL_TIM_PWM_ConfigChannel(&TIM3_Handler,&TIM3_CH2Handler,TIM_CHANNEL_2);//配置TIM3通道2

    HAL_TIM_PWM_Start(&TIM3_Handler,TIM_CHANNEL_2);//开启PWM通道2 	   
}
//定时器底册驱动，开启时钟，设置中断优先级
//此函数会被HAL_TIM_Base_Init()函数调用
void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
{
    if(htim->Instance==TIM3)
	{
		__HAL_RCC_TIM3_CLK_ENABLE();            //使能TIM3时钟
		HAL_NVIC_SetPriority(TIM3_IRQn,1,3);    //设置中断优先级，抢占优先级1，子优先级3
		HAL_NVIC_EnableIRQ(TIM3_IRQn);          //开启ITM3中断   
	}
	 if(htim->Instance==TIM4)
	{
		__HAL_RCC_TIM4_CLK_ENABLE();            //使能TIM3时钟
		HAL_NVIC_SetPriority(TIM4_IRQn,1,4);    //设置中断优先级，抢占优先级1，子优先级3
		HAL_NVIC_EnableIRQ(TIM4_IRQn);          //开启ITM3中断   
	}
}
//定时器底层驱动，时钟使能，引脚配置
//此函数会被HAL_TIM_PWM_Init()调用
//htim:定时器句柄
void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
{
	GPIO_InitTypeDef GPIO_Initure;

    if(htim->Instance==TIM3)
	{
		__HAL_RCC_TIM3_CLK_ENABLE();			//使能定时器3
		__HAL_AFIO_REMAP_TIM3_PARTIAL();		//TIM3通道引脚部分重映射使能
		__HAL_RCC_GPIOB_CLK_ENABLE();			//开启GPIOB时钟

		GPIO_Initure.Pin=GPIO_PIN_5;           	//PB5
		GPIO_Initure.Mode=GPIO_MODE_AF_PP;  	//复用推挽输出
		GPIO_Initure.Pull=GPIO_PULLUP;          //上拉
		GPIO_Initure.Speed=GPIO_SPEED_FREQ_HIGH;//高速
		HAL_GPIO_Init(GPIOB,&GPIO_Initure); 	
	}
}
//设置TIM通道2的占空比
//compare:比较值
void TIM_SetTIM3Compare2(u32 compare)
{
	TIM3->CCR2=compare;
}
//定时器3中断服务函数
void TIM3_IRQHandler(void)
{
    HAL_TIM_IRQHandler(&TIM3_Handler);
}
void TIM4_IRQHandler(void)
{
    HAL_TIM_IRQHandler(&TIM4_Handler);
}
//回调函数，定时器中断服务函数调用
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
    if(htim==(&TIM3_Handler))
    {
			if(led0onoff !=0){
				if(led0timer3count<=led0duty){
					LED0=0;
					//LED1 =0;
				}
				else if((led0timer3count<=period)&&(led0timer3count>led0duty))
				{
					LED0=1;
					//LED1=1;
				}
				else
				{
					led0timer3count=0;
					LED0=0;
					//LED1 =0;
				}
			  led0timer3count++;
			}
			else{
				LED0=1;
				//LED1 =1;
				led0timer3count=0;
			}

			if(led1onoff !=0){
				if(led1timer3count<=led1duty){
					LED1=0;
					//LED1 =0;
				}
				else if((led1timer3count<=period)&&(led1timer3count>led1duty))
				{
					LED1=1;
					//LED1=1;
				}
				else
				{
					led1timer3count=0;
					LED1=0;
					//LED1 =0;
				}
			  led1timer3count++;
			}
			else{
				LED1=1;
				//LED1 =1;
				led1timer3count=0;
			}

    }
		if(htim==(&TIM4_Handler))
    {
			led0timer4count++;
			led1timer4count++;
			if(led0timer4count>=led0timer)
			{
				led0timer4count=0;
				if(led0onoff==0)
				{
					led0onoff=1;
				}
				else
				{
					led0onoff=0;
				}
			}
      if(led1timer4count>=led1timer)
			{
				led1timer4count=0;
				if(led1onoff==0)
				{
					led1onoff=1;
				}
				else
				{
					led1onoff=0;
				}
			}  
    }
}
```
